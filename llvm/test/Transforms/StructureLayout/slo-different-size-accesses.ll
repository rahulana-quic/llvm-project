; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes="structure-layout" -S < %s | FileCheck %s

%struct.str_t = type { i32, i32, i32 }

@p = global ptr null, align 8

define void @foo(i32 noundef %num) {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: i32 noundef [[NUM:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[NUM]] to i64
; CHECK-NEXT:    [[MUL:%.*]] = mul nsw i64 [[CONV]], 12
; CHECK-NEXT:    [[CALL:%.*]] = tail call noalias ptr @malloc(i64 noundef [[MUL]])
; CHECK-NEXT:    store ptr [[CALL]], ptr @p, align 8
; CHECK-NEXT:    [[CMP13:%.*]] = icmp sgt i32 [[NUM]], 0
; CHECK-NEXT:    br i1 [[CMP13]], label %[[FOR_BODY_PREHEADER:.*]], label %[[FOR_END:.*]]
; CHECK:       [[FOR_BODY_PREHEADER]]:
; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext nneg i32 [[NUM]] to i64
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, %[[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [[STRUCT_STR_T:%.*]], ptr [[CALL]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr [[ARRAYIDX]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 [[TMP0]] to i32
; CHECK-NEXT:    [[CONV2:%.*]] = add i32 [[TMP1]], 1
; CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds i8, ptr [[ARRAYIDX]], i64 4
; CHECK-NEXT:    store i32 [[CONV2]], ptr [[B]], align 4
; CHECK-NEXT:    store i32 0, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_END]], label %[[FOR_BODY]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    ret void
;
entry:
  %conv = sext i32 %num to i64
  %mul = mul nsw i64 %conv, 12
  %call = tail call noalias ptr @malloc(i64 noundef %mul)
  store ptr %call, ptr @p, align 8
  %cmp13 = icmp sgt i32 %num, 0
  br i1 %cmp13, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext nneg i32 %num to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds %struct.str_t, ptr %call, i64 %indvars.iv
  %0 = load i64, ptr %arrayidx, align 8
  %1 = trunc i64 %0 to i32
  %conv2 = add i32 %1, 1
  %b = getelementptr inbounds i8, ptr %arrayidx, i64 4
  store i32 %conv2, ptr %b, align 4
  store i32 0, ptr %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret void
}

declare ptr @malloc(i64 noundef)
