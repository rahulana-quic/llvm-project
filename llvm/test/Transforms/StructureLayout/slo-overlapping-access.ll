; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes="structure-layout" -S < %s | FileCheck %s
; This case is not handled by the optimization yet. The transformed code is wrong.

%struct.str_t = type { i32, i32, i32 }

@p = global ptr null, align 8

define void @foo(i32 noundef %num) {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: i32 noundef [[NUM:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[NUM]] to i64
; CHECK-NEXT:    [[MUL:%.*]] = mul nsw i64 [[CONV]], 12
; CHECK-NEXT:    [[CALL:%.*]] = tail call noalias ptr @malloc(i64 noundef [[MUL]])
; CHECK-NEXT:    store ptr [[CALL]], ptr @p, align 8
; CHECK-NEXT:    [[CMP8:%.*]] = icmp sgt i32 [[NUM]], 0
; CHECK-NEXT:    br i1 [[CMP8]], label %[[FOR_BODY_PREHEADER:.*]], label %[[FOR_END:.*]]
; CHECK:       [[FOR_BODY_PREHEADER]]:
; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext nneg i32 [[NUM]] to i64
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, %[[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [[STRUCT_STR_T:%.*]], ptr [[CALL]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP0:%.*]] = mul i64 [[CONV]], 4
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[CALL]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = mul i64 [[INDVARS_IV]], 4
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP1]], i64 [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP4]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = mul i64 [[INDVARS_IV]], 4
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[CALL]], i64 [[TMP5]]
; CHECK-NEXT:    store i32 [[ADD]], ptr [[TMP6]], align 4
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_END]], label %[[FOR_BODY]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    ret void
;
entry:
  %conv = sext i32 %num to i64
  %mul = mul nsw i64 %conv, 12
  %call = tail call noalias ptr @malloc(i64 noundef %mul)
  store ptr %call, ptr @p, align 8
  %cmp8 = icmp sgt i32 %num, 0
  br i1 %cmp8, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext nneg i32 %num to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds %struct.str_t, ptr %call, i64 %indvars.iv
  %add.ptr = getelementptr inbounds i8, ptr %arrayidx, i64 1
  %0 = load i32, ptr %add.ptr, align 4
  %add = add nsw i32 %0, 1
  %b = getelementptr inbounds i8, ptr %arrayidx, i64 4
  store i32 %add, ptr %b, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret void
}

declare ptr @malloc(i64 noundef)
